<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/app/api/pages/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/pages/route.ts" />
              <option name="originalContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;// List pages by project slug&#10;export async function GET(req: NextRequest) {&#10;  const url = new URL(req.url)&#10;  const project = url.searchParams.get('project') || ''&#10;  if (!project) return NextResponse.json([])&#10;  const { rows } = await query(&#10;    `select p.id, p.slug, p.updated_at from pages p&#10;     join projects pr on pr.id = p.project_id&#10;     where pr.slug=$1&#10;     order by p.updated_at desc`,&#10;    [project]&#10;  )&#10;  return NextResponse.json(rows)&#10;}&#10;&#10;// Create or upsert a page content from GrapesJS JSON&#10;export async function POST(req: NextRequest) {&#10;  const body = await req.json().catch(() =&gt; ({})) as any&#10;  const { projectId, projectSlug, path, grapesJson } = body&#10;  const pageSlug = path || 'home'&#10;&#10;  // Resolve project id&#10;  let pid = projectId as string | null&#10;  if (!pid &amp;&amp; projectSlug) {&#10;    const { rows } = await query('select id from projects where slug=$1', [projectSlug])&#10;    pid = rows[0]?.id || null&#10;  }&#10;  if (!pid) return NextResponse.json({ error: 'projectId or projectSlug required' }, { status: 400 })&#10;&#10;  const g = grapesJson || {}&#10;  const gHtml = g['gjs-html'] || ''&#10;  const gCss = g['gjs-css'] || ''&#10;  const gComp = g['gjs-components'] || {}&#10;  const gStyles = g['gjs-styles'] || {}&#10;&#10;  await query(&#10;    `insert into pages(project_id, slug, gjs_html, gjs_css, gjs_components, gjs_styles)&#10;     values($1,$2,$3,$4,$5,$6)&#10;     on conflict (project_id, slug) do update set&#10;       gjs_html=excluded.gjs_html,&#10;       gjs_css=excluded.gjs_css,&#10;       gjs_components=excluded.gjs_components,&#10;       gjs_styles=excluded.gjs_styles,&#10;       updated_at=now()`,&#10;    [pid, pageSlug, gHtml, gCss, gComp, gStyles]&#10;  )&#10;&#10;  return NextResponse.json({ ok: true })&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;// List pages by project slug&#10;export async function GET(req: NextRequest) {&#10;  const url = new URL(req.url)&#10;  const project = url.searchParams.get('project') || ''&#10;  if (!project) return NextResponse.json([])&#10;  const { rows } = await query(&#10;    `select p.id, p.slug, p.updated_at from pages p&#10;     join projects pr on pr.id = p.project_id&#10;     where pr.slug=$1&#10;     order by p.updated_at desc`,&#10;    [project]&#10;  )&#10;  return NextResponse.json(rows)&#10;}&#10;&#10;// Create or upsert a page content from GrapesJS JSON&#10;export async function POST(req: NextRequest) {&#10;  const body = (await req.json().catch(() =&gt; ({}))) as Record&lt;string, unknown&gt;&#10;  const { projectId, projectSlug, path, grapesJson } = body as {&#10;    projectId?: string&#10;    projectSlug?: string&#10;    path?: string&#10;    grapesJson?: Record&lt;string, unknown&gt;&#10;  }&#10;  const pageSlug = path || 'home'&#10;&#10;  // Resolve project id&#10;  let pid = projectId || null&#10;  if (!pid &amp;&amp; projectSlug) {&#10;    const { rows } = await query('select id from projects where slug=$1', [projectSlug])&#10;    pid = (rows[0] as any)?.id || null&#10;  }&#10;  if (!pid) return NextResponse.json({ error: 'projectId or projectSlug required' }, { status: 400 })&#10;&#10;  const g = (grapesJson as Record&lt;string, unknown&gt;) || {}&#10;  const gHtml = (g['gjs-html'] as string) || ''&#10;  const gCss = (g['gjs-css'] as string) || ''&#10;  const gComp = (g['gjs-components'] as object) || {}&#10;  const gStyles = (g['gjs-styles'] as object) || {}&#10;&#10;  await query(&#10;    `insert into pages(project_id, slug, gjs_html, gjs_css, gjs_components, gjs_styles)&#10;     values($1,$2,$3,$4,$5,$6)&#10;     on conflict (project_id, slug) do update set&#10;       gjs_html=excluded.gjs_html,&#10;       gjs_css=excluded.gjs_css,&#10;       gjs_components=excluded.gjs_components,&#10;       gjs_styles=excluded.gjs_styles,&#10;       updated_at=now()`,&#10;    [pid, pageSlug, gHtml, gCss, gComp, gStyles]&#10;  )&#10;&#10;  return NextResponse.json({ ok: true })&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/projects/[id]/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/projects/[id]/route.ts" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;export async function GET(_req: NextRequest, { params }: { params: { id: string } }) {&#10;  const idOrSlug = params.id&#10;  // Try by UUID first, then by slug&#10;  const { rows: projRows } = await query(&#10;    `select id, slug, name, created_at from projects where id::text=$1 or slug=$1 limit 1`,&#10;    [idOrSlug]&#10;  )&#10;  const project = projRows[0]&#10;  if (!project) return NextResponse.json({ error: 'Not found' }, { status: 404 })&#10;&#10;  const { rows: pages } = await query(&#10;    `select id, slug, updated_at from pages where project_id=$1 order by updated_at desc`,&#10;    [project.id]&#10;  )&#10;&#10;  return NextResponse.json({ project, pages })&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/projects/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/projects/route.ts" />
              <option name="originalContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;export async function GET(req: NextRequest) {&#10;  const url = new URL(req.url)&#10;  const ws = url.searchParams.get('workspace')&#10;  if (!ws) return NextResponse.json([])&#10;  const { rows: tenant } = await query('select id from tenants where slug=$1', [ws])&#10;  if (tenant.length === 0) return NextResponse.json([])&#10;  const { rows } = await query('select id, slug, name from projects where tenant_id=$1 order by created_at desc', [tenant[0].id])&#10;  return NextResponse.json(rows)&#10;}&#10;&#10;export async function POST(req: NextRequest) {&#10;  const { workspace, name, slug, templateId } = await req.json()&#10;  const { rows: trows } = await query('select id from tenants where slug=$1', [workspace])&#10;  if (trows.length === 0) return NextResponse.json({ error: 'Workspace not found' }, { status: 404 })&#10;  const tenantId = trows[0].id&#10;  await query('insert into projects(tenant_id, slug, name) values($1,$2,$3)', [tenantId, slug, name])&#10;  // Create default page&#10;  if (templateId) {&#10;    const { rows: tpl } = await query('select gjs_html, gjs_css, gjs_components, gjs_styles from templates where id=$1', [templateId])&#10;    if (tpl.length) {&#10;      await query(&#10;        'insert into pages(project_id, slug, gjs_html, gjs_css, gjs_components, gjs_styles) values((select id from projects where tenant_id=$1 and slug=$2), $3, $4, $5, $6, $7)',&#10;        [tenantId, slug, 'home', tpl[0].gjs_html, tpl[0].gjs_css, tpl[0].gjs_components, tpl[0].gjs_styles]&#10;      )&#10;    }&#10;  } else {&#10;    await query('insert into pages(project_id, slug) values((select id from projects where tenant_id=$1 and slug=$2), $3)', [tenantId, slug, 'home'])&#10;  }&#10;  return NextResponse.json({ ok: true })&#10;}&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;export async function GET(req: NextRequest) {&#10;  const url = new URL(req.url)&#10;  const ws = url.searchParams.get('workspace')&#10;  if (!ws) return NextResponse.json([])&#10;  const { rows: tenant } = await query('select id from tenants where slug=$1', [ws])&#10;  if (tenant.length === 0) return NextResponse.json([])&#10;  const { rows } = await query('select id, slug, name from projects where tenant_id=$1 order by created_at desc', [tenant[0].id])&#10;  return NextResponse.json(rows)&#10;}&#10;&#10;export async function POST(req: NextRequest) {&#10;  const { workspace, workspaceId, name, slug, templateId } = await req.json()&#10;&#10;  // Resolve tenant id by provided workspaceId or slug&#10;  let tenantId: string | undefined&#10;  if (workspaceId) tenantId = workspaceId&#10;  if (!tenantId &amp;&amp; workspace) {&#10;    const { rows: trows } = await query('select id from tenants where slug=$1', [workspace])&#10;    if (trows.length) tenantId = trows[0].id&#10;  }&#10;  if (!tenantId) return NextResponse.json({ error: 'Workspace not found' }, { status: 404 })&#10;&#10;  const { rows: created } = await query(&#10;    'insert into projects(tenant_id, slug, name) values($1,$2,$3) returning id, slug, name',&#10;    [tenantId, slug, name]&#10;  )&#10;&#10;  // Create default page&#10;  if (templateId) {&#10;    const { rows: tpl } = await query('select gjs_html, gjs_css, gjs_components, gjs_styles from templates where id=$1', [templateId])&#10;    if (tpl.length) {&#10;      await query(&#10;        'insert into pages(project_id, slug, gjs_html, gjs_css, gjs_components, gjs_styles) values($1, $2, $3, $4, $5, $6)',&#10;        [created[0].id, 'home', tpl[0].gjs_html, tpl[0].gjs_css, tpl[0].gjs_components, tpl[0].gjs_styles]&#10;      )&#10;    }&#10;  } else {&#10;    await query('insert into pages(project_id, slug) values($1, $2)', [created[0].id, 'home'])&#10;  }&#10;  return NextResponse.json({ project: created[0] })&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/publish/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/publish/route.ts" />
              <option name="originalContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;export async function POST(req: NextRequest) {&#10;  const { project = 'unknown', page = 'home' } = await req.json().catch(() =&gt; ({}))&#10;  const { rows } = await query(&#10;    `select p.gjs_html, p.gjs_css from pages p&#10;    join projects pr on pr.id = p.project_id&#10;    where pr.slug=$1 and p.slug=$2`,&#10;    [project, page]&#10;  )&#10;&#10;  if (!rows.length) return NextResponse.json({ error: 'No page' }, { status: 404 })&#10;&#10;  await query(&#10;    `insert into publications(project_id, html, css)&#10;    values((select id from projects where slug=$1), $2, $3)`,&#10;    [project, rows[0].gjs_html, rows[0].gjs_css]&#10;  )&#10;&#10;  const base = process.env.NEXT_PUBLIC_BASE_DOMAIN || 'pages.localtest.me'&#10;  const url = `http://${project}.${base}/`&#10;  return NextResponse.json({ url })&#10;}&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;export async function POST(req: NextRequest) {&#10;  const { project = 'unknown', page = 'home' } = await req.json().catch(() =&gt; ({}))&#10;  const { rows } = await query(&#10;    `select p.gjs_html, p.gjs_css from pages p&#10;    join projects pr on pr.id = p.project_id&#10;    where pr.slug=$1 and p.slug=$2`,&#10;    [project, page]&#10;  )&#10;&#10;  if (!rows.length) return NextResponse.json({ error: 'No page' }, { status: 404 })&#10;&#10;  await query(&#10;    `insert into publications(project_id, html, css)&#10;    values((select id from projects where slug=$1), $2, $3)`,&#10;    [project, rows[0].gjs_html, rows[0].gjs_css]&#10;  )&#10;&#10;  const base = process.env.NEXT_PUBLIC_BASE_DOMAIN || 'pages.localtest.me'&#10;  const url = `http://${project}.${base}/`&#10;  return NextResponse.json({ url, deploymentUrl: url, status: 'deployed' })&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/app/api/templates/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/app/api/templates/route.ts" />
              <option name="originalContent" value="import { NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;export async function GET() {&#10;  const { rows } = await query(`select id, name, type, coalesce(meta-&gt;&gt;'preview','') as preview from templates order by created_at desc`)&#10;  return NextResponse.json(rows)&#10;}&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from 'next/server'&#10;import { query } from '@/lib/db'&#10;&#10;export async function GET() {&#10;  const { rows } = await query(`select id, name, type, coalesce(meta-&gt;&gt;'preview','') as preview from templates order by created_at desc`)&#10;  return NextResponse.json(rows)&#10;}&#10;&#10;export async function POST(req: NextRequest) {&#10;  const body = (await req.json().catch(() =&gt; ({}))) as Record&lt;string, unknown&gt;&#10;  const { name, type = 'page', grapesJson, meta } = body as {&#10;    name?: string&#10;    type?: string&#10;    grapesJson?: Record&lt;string, unknown&gt;&#10;    meta?: Record&lt;string, unknown&gt;&#10;  }&#10;  if (!name) return NextResponse.json({ error: 'name required' }, { status: 400 })&#10;&#10;  const g = grapesJson || {}&#10;  const gHtml = (g['gjs-html'] as string) || ''&#10;  const gCss = (g['gjs-css'] as string) || ''&#10;  const gComp = (g['gjs-components'] as object) || {}&#10;  const gStyles = (g['gjs-styles'] as object) || {}&#10;&#10;  await query(&#10;    `insert into templates(name, type, gjs_html, gjs_css, gjs_components, gjs_styles, meta)&#10;     values($1,$2,$3,$4,$5,$6,$7)`,&#10;    [name, type, gHtml, gCss, gComp, gStyles, meta || {}]&#10;  )&#10;&#10;  return NextResponse.json({ ok: true })&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>